# DesignPattern

디자인 패턴 학습   

- 클래스 -> 객체를 구현하기 위해 내부의 데이터, 표현방법과 오퍼레이션을 정의한 것   
- 객체 -> 클래스로부터 인스턴스가 생성 된 결과 ( 객체 내부의 데이터에 대해서 메모리 할당 및 데이터를 오퍼레이션들과 관련짓는것 )    
- 추상클래스 -> 모든 서브클래스들 사이의 공통되는 인터페이스를 정의한 것   
- 인터페이스 -> 객체가 정의하는 오퍼레이션(함수)의 집합

### 클래스 상속 vs 인터페이스 상속

- 클래스 상속은 이미 구현된 객체를 바탕으로 한다.   
  클래스 상속을 하려면 이미 객체로 구현되어 있어야한다.   
  객체로 구현되어 있다는 의미는 오퍼레이션이 이미 구현되어 있고 상속을 받는곳에서는 그 오퍼레이션을 재사용 하거나 오버라이딩 할 수 있음을 의미한다.   
  
- 인터페이스 상속은 객체가 다른곳에서 사용 될 수 있음을 의미한다.   
  인터페이스 상속을 하면 실제적인 구현체가 없고 인터페이스 타입으로 받을 수 있다는걸 의미한다.   
  사용 가능성을 강조하고 다형성을 가진다는 것을 의미한다.    

구현이 아닌 인터페이스에 따라 프로그래밍 하자!!!     

변수를 구체적 클래스의 인스턴스로 선언하지 말고 추상 클래스의 인터페이스를 만족하도록 인스턴스 변수를 정의      
   
### 클래스 상속 vs 객체 합성    
   
- 상속의 경우 부모 클래스의 영향을 받을 수 밖에 없다.   
  런타임 시에 상속받은 부모 클래스의 구현을 변경 할 수 없음    
  캡슐화를 파괴 (protected, public 으로 선언한 변수에 접근 가능, 메소드 오버라이딩시 private 로 정의 되어있는 메소드를 protected 로 변경해서 가시성 확대 )       

- 객체의 합성은 다른 객체에 대한 참조를 얻는 방식   
  런타임 시에 동적으로 이루어짐   
  인터페이스를 통해서만 접근 가능하므로 캡슐화를 유지   

클래스의 상속과 객체의 합성을 함께 실행 되어야 완벽한 재사용 가능    
   
### 위임

   - 수신 객체가 오퍼레이션의 처리를 위임자에게 전달해서 위임자가 처리하도록 하는 방식
   - 런타임 시에 객체가 결정되어서 복잡하고 이해하기가 어렵다.   

   
## Composite Pattern

## Builder Pattern
