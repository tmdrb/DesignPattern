# DesignPattern

디자인 패턴 학습   

- 클래스 -> 객체를 구현하기 위해 내부의 데이터, 표현방법과 오퍼레이션을 정의한 것   
- 객체 -> 클래스로부터 인스턴스가 생성 된 결과 ( 객체 내부의 데이터에 대해서 메모리 할당 및 데이터를 오퍼레이션들과 관련짓는것 )    
- 추상클래스 -> 모든 서브클래스들 사이의 공통되는 인터페이스를 정의한 것   
- 인터페이스 -> 객체가 정의하는 오퍼레이션(함수)의 집합

### 클래스 상속 vs 인터페이스 상속

- 클래스 상속은 이미 구현된 객체를 바탕으로 한다.   
  클래스 상속을 하려면 이미 객체로 구현되어 있어야한다.   
  객체로 구현되어 있다는 의미는 오퍼레이션이 이미 구현되어 있고 상속을 받는곳에서는 그 오퍼레이션을 재사용 하거나 오버라이딩 할 수 있음을 의미한다.   
  
- 인터페이스 상속은 객체가 다른곳에서 사용 될 수 있음을 의미한다.   
  인터페이스 상속을 하면 실제적인 구현체가 없고 인터페이스 타입으로 받을 수 있다는걸 의미한다.   
  사용 가능성을 강조하고 다형성을 가진다는 것을 의미한다.    

구현이 아닌 인터페이스에 따라 프로그래밍 하자!!!     

변수를 구체적 클래스의 인스턴스로 선언하지 말고 추상 클래스의 인터페이스를 만족하도록 인스턴스 변수를 정의      
   
### 클래스 상속 vs 객체 합성    
   
- 상속의 경우 부모 클래스의 영향을 받을 수 밖에 없다.   
  런타임 시에 상속받은 부모 클래스의 구현을 변경 할 수 없음    
  캡슐화를 파괴 (protected, public 으로 선언한 변수에 접근 가능, 메소드 오버라이딩시 private 로 정의 되어있는 메소드를 protected 로 변경해서 가시성 확대 )       

- 객체의 합성은 다른 객체에 대한 참조를 얻는 방식   
  런타임 시에 동적으로 이루어짐   
  인터페이스를 통해서만 접근 가능하므로 캡슐화를 유지   

클래스의 상속과 객체의 합성을 함께 실행 되어야 완벽한 재사용 가능    
   
### 위임

   - 수신 객체가 오퍼레이션의 처리를 위임자에게 전달해서 위임자가 처리하도록 하는 방식
   - 런타임 시에 객체가 결정되어서 복잡하고 이해하기가 어렵다.   

************************


## 생성 Pattern   

   - 인스턴스를 만드는 과정을 추상화 해서 객체를 생성 하는 패턴
   - 사용자는 구체적인 생성 방법을 몰라도 되기 때문에 유연하게 개발 가능

### Abstract Factory   

   - 구체적으로 서브클래스들을 정의하지 않아도 상속받은 객체를 생성하기 위한 인터페이스 제공
   - 하나의 추상화된 팩토리를 생성하고 이와 관련된 객체들을 생성하기 위한 팩토리를 실질적으로 구현해서 사용
   - 서브클래스 팩토리들과 추상화된 팩토리 사이에 종속성이 발생
   - 생성을 시스템과 독립적으로 만들때 사용
   - 확장성이 낮다

### Prototype   

   - 객체 생성시 clone 을 사용해서 재사용성을 높여준다.
   - 초기에 한번만 load 하고 객체를

### Builder
  
   - 복잡한 객체를 생성하는 클래스를 별도로 분리


### Factory Method

   - 서브클래스에서 인스턴스의 생성을 하도록 한다.
   - 반드시 구체적인 Creator 가 구현되어 있어야 한다.
   - 

### SingleTone

   - 인스턴스를 하나만 만들 필요가 있을때 사용한다.

************************

## 구조 패턴

### Adapter 

  - 클래스의 엔터페이스를 클라이언트가 기대하는 형태의 인터페이스로 변환
  - 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작

### Bridge

   - 

